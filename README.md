# week_4_of_rust_study

**作业7**

使用枚举包裹三个不同的类型，并放入一个Vec中，对Vec进行遍历，调用三种不同类型的各自的方法。

定义三个不同的类型，使用Trait Object，将其放入一个Vec中，对Vec进行遍历，调用三种不同类型的各自的方法。

代码 1 - 52 行使用枚举。

代码 58 - 108 行使用Trait。

输出：
```
TypeA: Hello
TypeB: 42
TypeC: 3.14
```

<br>

**作业8**

为自己定义的一个类型或多个类型实现加法运算（用符号 +），并构思使用Trait Object实现类型方法的调用。

代码 111 - 150 行

输出
```
Doing something with MyType: MyType { value: 30 }
```

### 区别

1. **类型检查**：
   - **枚举方法**：Rust 在编译时检查枚举的每种变体，保证类型安全。
   - **Trait(特质) 对象**：使用动态分发（Dynamic(动态) Dispatch）。Rust 在运行时解析调用的方法，这带来了一些性能开销。
2. **内存布局**：
   - **枚举方法**：枚举的大小等于其最大变体的大小。
   - **Trait(特质) 对象**：通常使用指针（如 `Box<dyn Trait>`），这意味着它们有固定的大小，但需要堆分配。
3. **灵活性**：
   - **枚举方法**：适合已知且数量有限的类型变体。
   - **Trait 对象**：更灵活，可以在运行时组合不同的类型，适用于类型数量不确定或者在编译时未知的情况。
4. **性能考虑**：
   - **枚举方法**：通常性能更高，因为它使用静态分发。
   - **Trait 对象**：因为动态分发可能带来一些运行时性能开销。